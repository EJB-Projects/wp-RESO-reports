# WP RESO RU. ICEFaces Reports Tree to PrimeFaces. RELEASE №22

EJBPrimeFaces 22 (ActionListener)




Короче, по-русски напишу.

В общем это пока такая промежуточная версия. Есть закомментированный упрощенный Ресовский код. Это в основном класс  ReportController, который у меня называется MainBean пока и структура классов, которые нужны, чтобы он хоть как-то работал. Часть классов мне вообще не дали: это классы из пакетов srv (видимо, что-то серверное), admin и прочее. Поэтому вместо них просто сделал пустышки/болванки/Моки самописные. 

Результат работы промежуточный: попытка оставить все как есть, написать парсер тупо, подпихнуть его в работающий код и менять только фронтенд не прокатила. То есть иметь в одном проекте  jar'ы и PrimeFaces и ICEFaces не получилось. Я честно ипался два дня: все это сцуко глючило не реально: бесконечные nullPointerException и прочее. В итоге мы посоветовались с kajam, решили забить на это хер и писать  с нуля. Поэтому вот это пока просто болваночная версия, которая парсит все то дерево, которое готовится... точнее готовиЛОСЬ в IceFaces, в старом коде, и выкидывает его на страничку, которая уже работает на PrimeFaces. Закрепимся в этой ревизии и следающая версия уже будет.... как сказать.... В общем я буду притягивать весь остальной старый ресовский код сюда. Ну, естественно придется много чего переписывать или писать вообще заново.

Результат главный: в целом все работает: я готовлю (тупо задавая данные через переменные в конструкторе в соответствующем классе) некое "липовое" локальное дерево отчетов и папок, отдаю его своему парсеру и он все перехерачивает это в дерево PrimeFaces уже. Херь в том, что в предыдущем коде там все хитро было. Они использовали Свинговое (Swing) DefaultMutableTree или как оно там, наполняли его объектами, а списки отчетов держали в ArrayList. То есть по сути их главная собирающая свинговое дерево процедура build-чо-то-там-reportTree хавает свинговое дерево и ArrayList папок отчетов. А я своим TreeParse уже из него леплю Праймфейсовское. 



17.05.2018 [10:18] - РЕЗУЛЬТАТ ДАННОГО РЕЛИЗА: Значит, что сделал? В этой версии релиза я пытался разобраться с ActionListener. То есть прикрутить реакцию на события нажатия на ноды списка. Сделал не до конца. Думаю, до конца сделаю в следующей, 23-й реализации (хотя не факт). Ну открывать прям отчет он не будет. Но будет какая-то болваночная заготовка, чтобы это реализовать в следующих версиях. Пока нет даже этого. В этой, 22-й реалзиации пока просто окунулся в проблему. Итак, в чем была проблема...

ПРОБЛЕММАТИКА: как работало раньше? Они брали id папки из SQL. Так же брали id отчета из SQL. Потом, у них было две обертки (wrapper) для userobject. Отдельно для папки и для отчета. То есть по сути это объект, наследующий ICEFacesUserObject, который в свою очередь прописан в их (их - айсфейсовских) jar'ах. 

Для тех кто не в теме или если сам забуду: Айсфейсовский юзеробжект это такая сущность как бы, которую можно нашпиговать всякой важной для отрисовки и работы дерева херней прям в джаве, пихнуть его в дерево опять же прям в джаве и jsf сам его скорлупу раскроет, чо надо возьмет и все отрисует. Туда можно пихать и иконки папок, стилей (так собственно у инх и было), они туда же пихают и параметры всякие такие как id папки/отчета, которые должны быть визуально скрыты от юзера. 

Они его экстендили (extends) и дополняли своими свойствами. В частности id. А Геттер там был такой, что они вставляли ебанутый делиметр "N". Потому что папка например у них была N1547859, а отчет у этой папки N1547859N4557488. Они у каждый ноды уже в jsf делали commandLink, который позволяет добавить такую шнягу как <f:param, куда они пихали этот юзеробжект. А потом на событие выделение они блять его через getRequestParam у FaceContext его считывали, парсили отдельной функцией и определяли нужную папку и нужный отчет. Ну, в смысле выделенный юзером. И Свинговое деревце, DefaultMutableTree даже имеет такой метод как setUserObject, которому можно пропихнуть как раз врапперы ICEFacesUserObject. Но у PrimeFaces-то нету UserObect'а. И вся эта логика мля летит к чертям. Чо делать-то? Я сначала ипался, запихнул там тоже commandLink, туда пихнул тот же <f:param... чо-то там мутил. Ни хера не вышло.

РЕШЕНИЕ: что сделано? В итоге выяснил, что у PrimeFaces TreeNode есть методы setRowKey и getRowKey. РоуКей там пиздец конечно у него. Типа корень у него 0_0, первый уровень это 1_0, второй 1_1, дочка будет 1_1_1 и так далее и все это в Стринге. Короче, люди не парились особо, епты. В общем, сделал класс обертку. Туда пихнул мапу и treeparse. И теперь не как раньше дергаю TreeParse сразу, а дергаю этот класс, он сам запускает парсинг и кладет при парсинге тут же созданные роукеи как ключи, а id папки/отчета как value. Ну и при щелчке пока выводит их в message в growl. 

TO DO: Чо надо будет сделать в 23-ей версии? Вообще в 23-й версии я б хотел найти на улице чемодан с пол ляма баксов и свалить на Бора Бора, но на всякий случай:

- надо убрать на хуй этот commandLink с его <f:param.
- надо найти нормальные id папки/отчета и захерачить их в мапу, потому что пока там ваще пиздец: там id генериться рандомно
- надо по этому id научиться выставлять правильную папку и отчет. Ну и пока выводить это все в мессадж.

Проваливаться на следующую страничку - это будем делать в следующих после 23-й реализациях. В 24-й и так далее.....
